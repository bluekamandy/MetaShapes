// A class that takes three shapes (triangles, rectangles, and ellipses) and
// compiles them into working processing code as a text file.

class ShapeCompiler {

  PrintWriter codeForShapes;

  ArrayList<PVector> calculatedPositions;

  ShapeCompiler() {
    
  }

  void saveImageAsPDE() {
    processPositionOffsets();
    long d = System.currentTimeMillis();
    saveImageAsPNG(d);
    codeForShapes = createWriter("code" + d + "/code" + d + ".pde");

    codeForShapes.print("/**\n * This program was generated by MetaShapes.\n * \n * programmed\n * by\n * M A S O O D\n */\n\n");

    // Declare PShapes

    for (int i = 0; i < shapeList.shapes.size(); i++) {
      codeForShapes.print("PShape shape" + i + ";\n");
    }

    codeForShapes.print("\nvoid setup() {\n  size(" + canvasW + ", " + canvasH + ");\n");
    codeForShapes.print("  noStroke();\n");
    codeForShapes.print("  shapeMode(CENTER);\n");

    // Initialize Shapes

    for (int i = 0; i < shapeList.shapes.size(); i++) {
      switch (shapeList.shapeTypes.get(i)) {
      case "TRIANGLE":
        PVector[] points = createEqTrianglePoints(0, 0, shapeList.sizes.get(i).y);
        codeForShapes.print("  shape" + i + " = createShape(TRIANGLE, " + points[0].x + ", " + points[0].y + ", " + points[1].x + ", " + points[1].y + ", " + points[2].x + ", " + points[2].y + ");\n");
        break;
      case "RECT":
        codeForShapes.print("  shape" + i + " = createShape(RECT, -" + shapeList.sizes.get(i).x + "/2, -" + shapeList.sizes.get(i).y/2 + ", " + shapeList.sizes.get(i).x +", " + shapeList.sizes.get(i).y + ");\n");
        break;
      case "ELLIPSE":
        //codeForShapes.print("  shape" + i + " = createShape(ELLIPSE, -" + shapeList.sizes.get(i).x + "/2, -" + shapeList.sizes.get(i).y/2 + ", " + shapeList.sizes.get(i).x +", " + shapeList.sizes.get(i).y + ");");
        codeForShapes.print("  shape" + i + " = createShape(ELLIPSE, 0, 0, " + shapeList.sizes.get(i).x +", " + shapeList.sizes.get(i).y + ");\n");
        break;
      }
    }


    codeForShapes.print("}\n\n");

    codeForShapes.print("void draw() {\n  ");
    codeForShapes.print("background(" + shapeCanvas.backgroundColor + ");\n");

    // Draw shapes

    for (int i = 0; i < shapeList.shapes.size(); i++) {
      // push
      codeForShapes.print("  push();\n");
      //translate
      codeForShapes.print("  translate(" + calculatedPositions.get(i).x + ", " + calculatedPositions.get(i).y + ");\n");
      // rotate
      codeForShapes.print("  rotate(" + shapeList.rotations.get(i) + ");\n");
      // fill color
      codeForShapes.print("  shape" + i + ".setFill(" + shapeList.colors.get(i) + ");\n");
      // draw shape
      codeForShapes.print("  shape(shape" + i + ", 0, 0);\n");
      // pop
      codeForShapes.print("  pop();\n");
    }

    codeForShapes.print("}");


    codeForShapes.flush();
    codeForShapes.close();
  }

  void processPositionOffsets() {
    calculatedPositions = new ArrayList<PVector>();
    for (int i = 0; i < shapeList.shapes.size(); i++) {
      PVector newPos = new PVector(shapeList.positions.get(i).x - (width/2 - canvasW/2), shapeList.positions.get(i).y - (height/2 - canvasH/2 + 100));
      calculatedPositions.add(newPos);
    }
  }
  
  void saveImageAsPNG(long d) {
    PImage img = shapeCanvas.canvas.get(width/2 - canvasW/2, height/2 - canvasH/2 + 100, canvasW, canvasH); 
    img.save("code" + d + "/image" + d + ".png");
  }
}
